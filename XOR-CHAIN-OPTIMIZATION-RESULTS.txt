XOR Chain Sharing Optimization Results
======================================================================

XOR with Constants Optimization:
  - XOR(CONST-0, x) = x (identity)  [eliminates 4 NANDs per occurrence]
  - XOR(CONST-1, x) = NOT(x)        [reduces 4 NANDs to 1]

ANALYSIS (from analyze-xor-sharing.py):
  Total XOR patterns found:     56,832
  XOR(CONST-0, x) occurrences:     600
  XOR(CONST-1, x) occurrences:       0

CIRCUIT GENERATION (Unoptimized):
  Previous (nands.txt):        461,568 gates
  XOR-optimized:               456,768 gates
  Direct savings:                4,800 gates (1.04%)
    - 600 XOR outputs replaced with identity
    - 4,200 intermediate gates removed via dead code elimination

FULL OPTIMIZATION PIPELINE:
======================================================================
Stage                    Previous     XOR-Opt      Improvement
----------------------------------------------------------------------
Unoptimized             461,568      456,768      -4,800 (-1.04%)
Basic optimizer         412,008      410,808      -1,200 (-0.29%)
Advanced optimizer      260,440      259,240      -1,200 (-0.46%)
MAJ rewriter            246,072      244,872      -1,200 (-0.49%)
Constant propagation    241,057      239,865      -1,192 (-0.49%)
======================================================================

FINAL RESULTS:
  Previous best:    241,057 gates
  New best:         239,865 gates
  TOTAL SAVED:       1,192 gates (0.49% additional reduction)

Overall reduction from original: 53.1% (461,568 → 239,865)

All 25 verification tests passed!

IMPLEMENTATION:
1. Created xor-share-optimizer.py:
   - Identifies XOR patterns in NAND circuit
   - Recognizes XOR(CONST-0, x) = x optimizations
   - Recognizes XOR(CONST-1, x) = NOT(x) optimizations
   - Uses dead code elimination to remove unreferenced intermediates
   - Safely handles replacement chains

2. Run before standard optimization pipeline:
   python xor-share-optimizer.py -i nands.txt -o nands-xor-opt.txt
   python optimize-nands.py -i nands-xor-opt.txt -o nands-xor-opt-basic.txt
   python advanced-optimizer.py -i nands-xor-opt-basic.txt -o nands-xor-opt-advanced.txt
   python maj-rewriter.py -i nands-xor-opt-advanced.txt -o nands-xor-opt-maj.txt
   python constant-propagation.py -i nands-xor-opt-maj.txt -o nands-xor-final.txt

3. Files generated:
   - nands-xor-opt.txt: 456,768 gates (after XOR optimization)
   - nands-xor-final.txt: 239,865 gates (fully optimized)

KEY INSIGHT:
The XOR(CONST-0, x) = x optimization is particularly effective because:
1. In SHA-256, many ADD operations start with carry=0 (CONST-0)
2. Full adders internally use XOR for sum computation
3. When carry input is CONST-0, the first XOR in the adder chain simplifies
4. Found 600 such patterns throughout the circuit
5. Each elimination removes 4 NANDs plus intermediate gates

CUMULATIVE RESULTS (from original 510,208 gates):
  CH optimization (9→4 NANDs):     -48,640 gates (-9.5%)
  XOR chain sharing:                -4,800 gates (-1.0% additional)
  Standard optimizations:         -225,903 gates (-44.3% additional)
  Total reduction:                -270,343 gates (53.0% total)

Final: 239,865 gates (47.0% of original size)
